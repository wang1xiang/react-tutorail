#### 解决问题

- 对渲染的控制，渲染组件、懒加载/动态加载组件
- 让props中混入一些需要的东西：将可以改变路由的history混入props中，于是withRouter诞生了
- 监控组件内部状态，对组件做一些赋能

#### 两种不同的高阶组件

##### 属性代理

用组件包裹一层代理组件，做一些强化操作 案例1

- 优点
  1. 可以和业务组件低耦合，对于条件渲染和props属性增强，只负责控制子组件渲染和传递额外的props就可以了
  2. 同样适用于类组件和函数组件
  3. 属性代理返回新的组件，可以控制业务组件是否渲染
  4. 嵌套使用
- 缺点
  1. 无法直接获取原始组件状态，需要通过ref获取组件实例
  2. 无法直接继承静态属性
  3. 因为本质上是一个新组件，所以需要配合forwardRef来转发ref

##### 反向继承

反向继承和属性代理有一定的区别，在于包装后的组件继承了原始组件本身，此时无须再去挂载业务组件 案例2

- 优点
  1. 方便获取组件内部状态，比如state、props、生命周期和绑定的事件函数等
  2. es6继承可以良好继承静态属性，不需要对静态属性和方法进行额外的处理
- 缺点
  1. 函数组件无法使用
  2. 和被包装的组件耦合度高，需要知道被包装的原始组件内部状态
  3. 如果多个反向继承HOC嵌套在一起，当前状态会覆盖上一个状态

#### 如何编写高阶组件

##### 强化props

在原始组件的props基础上，增加新的props，强化组件 案例3

##### 控制渲染

  HOC反向继承模式，可以通过super.render()得到render之后的内容，利用这一点可以做渲染劫持，或修改render之后的React element对象

- 渲染劫持 案例4
  
- 修改渲染树 案例5

- 动态加载 案例6

##### 组件赋能

- ref获取实例 案例7
  属性代理不能直接获取组件内的状态，通过ref获取组件实例，通过获取状态、触发事件等进一步强化组件
- 事件监控 案例8
  HOC不一定非要对组件本身做什么，可以单纯增加一些事件监听或错误监听

#### HOC总结

1. 强化props，通过HOC，向组件混入一些状态
2. 渲染劫持，利用HOC，动态挂载原始组件，还可以先获取原始组件的渲染树，进行可控性渲染
3. 可以配合import等api，实现动态加载组件，实现代码分割，加入loading效果
4. 可以通过ref获取组件实例，操作实例上的属性和方法
5. 可以对原始组件做事件监听，错误监控等

#### 注意事项

1. 不要再函数组件内部或类组件render函数中使用HOC

   ```jsx
   // 类组件中错误写法
   class Index extends React.Component{
    render(){
      const WrapHome = HOC(Home)
      return <WrapHome />
    }

  }
  // 函数组件中错误写法
  function Index(){
     const WrapHome = HOC(Home)
     return  <WrapHome />
  }

  ```
  这样导致每次类组件触发render或函数组件执行都会产生一个新的WrapHome组件，react diff会判定两次不是同一个组件，就会卸载老组件，重新挂载新组件
2.
